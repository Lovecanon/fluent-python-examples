### 第20章 属性描述符 514
#### 20.1 描述符示例：验证属性 514
#### 20.1.1 LineItem 类第3 版：一个简单的描述符 515
#### 20.1.2 LineItem 类第4 版：自动获取储存属性的名称 519
#### 20.1.3 LineItem 类第5 版：一种新型描述符 524
#### 20.2 覆盖型与非覆盖型描述符对比 526
* 覆盖型描述符：描述符中定义了__set__方法
* 非覆盖型描述符：描述符中没有定义__set__方法

一句话总结：描述符会不会覆盖实例属性；反过来说，实例属性会不会遮盖描述符
#### 20.2.1 覆盖型描述符 528
#### 20.2.2 没有 __get__ 方法的覆盖型描述符 529
#### 20.2.3 非覆盖型描述符 530
#### 20.2.4 在类中覆盖描述符 531
#### 20.3 方法是描述符 531
非覆盖型描述符的一种具体类型：方法。通过实例访问依附在类上的函数，经由描述符协议的处理，就会变成方法。

#### 20.4 描述符用法建议 533
* 使用特性以保持简单
内置的 property 类创建的其实是覆盖型描述符， __set__ 方法和 __get__ 方法都实现了， 即便不定义设值方法也是如此。 特性的
__set__ 方法默认抛出 AttributeError: can’t set attribute，因此创建只读属性最简单的方式是使用特性， 这能避免下一条所述
的问题。

* 只读描述符必须有 __set__ 方法
如果使用描述符类实现只读属性， 要记住， __get__ 和 __set__ 两个方法必须都定义， 否则， 实例的同名属性会遮盖描述符。
只读属性的 __set__ 方法只需抛出 AttributeError 异常， 并提供合适的错误消息。

* 用于验证的描述符可以只有 __set__ 方法
对仅用于验证的描述符来说， __set__ 方法应该检查 value 参数获得的值， 如果有效， 使用描述符实例的名称为键， 直接在实例的
__dict__ 属性中设置。 这样， 从实例中读取同名属性的速度很快， 因为不用经过 __get__ 方法处理。

* 仅有 __get__ 方法的描述符可以实现高效缓存
如果只编写了 __get__ 方法， 那么创建的是非覆盖型描述符。 这种描述符可用于执行某些耗费资源的计算， 然后为实例设置
同名属性，缓存结果。 同名实例属性会遮盖描述符， 因此后续访问会直接从实例的 __dict__ 属性中获取值， 而不会再触发描述符
的 __get__ 方法。

* 非特殊的方法可以被实例属性遮盖
由于函数和方法只实现了 __get__ 方法， 它们不会处理同名实例属性的赋值操作。 因此， 像 my_obj.the_method = 7 这样简单赋值
之后， 后续通过该实例访问 the_method 得到的是数字 7——但是不影响类或其他实例。 然而， 特殊方法不受这个问题的影响。
解释器只会在类中寻找特殊的方法， 也就是说， repr(x) 执行的其实是 x.__class__.__repr__(x)， 因此 x 的 __repr__ 属性对
repr(x) 方法调用没有影响。 出于同样的原因， 实例的 __getattr__ 属性不会破坏常规的属性访问规则。


#### 20.5 描述符的文档字符串和覆盖删除操作 534
#### 20.6 本章小结 535
#### 20.7 延伸阅读 536