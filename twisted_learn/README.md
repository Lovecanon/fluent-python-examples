
[我看到的最棒的Twisted入门教程(英文版)](http://krondo.com/in-which-we-begin-at-the-beginning/)

[我看到的最棒的Twisted入门教程(中文版)](http://blog.sina.com.cn/s/blog_704b6af70100py9n.html)
## 第一部分：Twisted理论基础
Twisted是一个高度抽象的体系，因此在使用它时，你会体会到其多层次性。但当你去学习尤其是尝试着理解它是如何工作时，
这种为抽像而带来的多层次性会给你带来极大的理解难度。所以，我们准备来个从内到外，从低层开始学习它。

#### 模型
* 单线程的同步模型
* 多线程模式

每个任务都在单独的线程中完成。

* 异步编程模型
在单线程的控制下任务是交错完成。

在异步编程模型与多线程模型之间不同：在多线程程序中，对于停止某个线程启动另外一个线程，其决定权并不在程序员手里
而在操作系统那里，因此，程序员在编写程序过程中必须要假设在任何时候一个线程都有可能被停止而启动另外一个线程。相反，在异
步模型中，一个任务要想运行必须显式放弃当前运行的任务的控制权。这也是相比多线程模型来说，最简洁的地方。

#### 动机
我们已经看到异步编程模型之所以比多线程模型简单在于其单令流与显式地放弃对任务的控制权而不是被操作系统随机地停止。但是
异步模型要比同步模型复杂得多。程序员必须将任务组织成序列来交替的小步完成。因此，若其中一个任务用到另外一个任务的输出，
则依赖的任务（即接收输出的任务）需要被设计成为要接收系列比特或分片而不是一下全部接收。由于没有实质上的并行，一个异步
程序会花费一个同步程序所需要的时间，可能会由于异步程序的性能问题而花费更长的时间。

因此，就要问了，为什么还要使用异步模型呢？ 在这儿，我们至少有两个原因。首先，如果有一到两个任务需要完成面向人的接口，
如果交替执行这些任务，系统在保持对用户响应的同时在后台执行其它的任务。因此，虽然后台的任务可能不会运行的更快，但这样的
系统可能会欢迎的多。其次还有一种情况，但任务被强行等待或阻塞时，异步模型的性能会高于同步模型，有时甚至会非常突出，即在
比较短的时间内完成所有的任务。

异步程序背后的最主要的特点在于，当出现一个任务像在同步程序一样出现阻塞时，会让其它可以执行的任务继续执行，而不会像
同步程序中那样全部阻塞掉。因此一个异步程序只有在没有任务可执行时才会出现“阻塞”，这也是为什么异步程序被称为非阻塞
程序的原因。

与同步模型相比，异步模型的优势在如下情况下会得到发挥：
1.有大量的任务，因此在一个时刻至少有一个任务要运行

2.任务执行大量的I/O操作，这样同步模型就会在因为任务阻塞而浪费大量的时间

3.任务之间相互独立，以至于任务内部的交互很少












